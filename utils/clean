#! /usr/bin/env python3
"""Cleans directories of files based on specified patterns."""

import os
from sys import stdout, argv
from getopt import getopt
from subprocess import check_output
from re import compile


def main():
    """Main function"""
    short_options = 'adrvf:'
    long_options = ['ask', 'rmdir', 'dry', 'recursive', 'verbose', 'help',
                    'version', 'file=', 'directory=']
    cli_patterns = []
    compiled_pattern = None

    cleanfile = ''
    directory = './'

    argv_opts, cli_patterns = getopt(argv[1:], short_options, long_options)
    options = init_options(argv_opts)

    if options['directory']:
        directory = validate_directory(options['directory'])
    if cli_patterns:
        compiled_pattern = compile_cli_patterns(cli_patterns)
    else:
        if options['file']:
            cleanfile = validate_cleanfile(options['file'])
        else:
            cleanfile = find_cleanfile(directory)
        options = merge(options, parse_cleanfile_options(cleanfile))
        compiled_pattern = compile_cleanfile_patterns(cleanfile)

    if options['verbose']:
        print(f'Cleanfile: {cleanfile}\tDirectory: {directory}\n'
              f'Options: {options}')

    walk = os.walk(directory)
    if options['recursive']:
        for dirname, dirs, files in walk:
            clean_files((dirname, dirs, files), compiled_pattern, options)
            if options['rmdir']:
                clean_dirs((dirname, dirs, files), compiled_pattern, options)
    else:
        walkinfo = next(walk)
        clean_files(walkinfo, compiled_pattern, options)
        if options['rmdir']:
            clean_dirs(walkinfo, compiled_pattern, options)

    if options['verbose']:
        print('Done')


def init_options(cli_options):
    """Init program options based on cli input (cli_options)"""
    options = {'file': '', 'directory': '', 'ask': False, 'dry': False,
               'rmdir': False, 'recursive': False, 'verbose': False}
    for option, value in cli_options:
        if option in ('-a', '--ask'):
            options['ask'] = True
        elif option in ('-d', '--rmdir'):
            options['rmdir'] = True
        elif option in ('-r', '--recursive'):
            options['recursive'] = True
        elif option in ('-v', '--verbose'):
            options['verbose'] = True
        elif option == '--dry':
            options['dry'] = True
        elif option in ('-f', '--file'):
            options['file'] = os.path.expanduser(value)
        elif option == '--directory':
            options['directory'] = os.path.expanduser(value)
        elif option == '--help':
            print_help()
        elif option == '--version':
            print_version()
    return options


def print_help():
    """Print help and exit"""
    dialog = '''Usage: clean [ OPTIONS ]... [ PATTERNS ]
    Cleans a directory based on specified patterns.

    If PATTERNS are not specified, the script will search DIRECTORY for a file
    named 'cleanfile'. Each pattern is treated as an extended regular expression.

        -f, --file=FILE             Cleanfile to read if no patterns are given.
            --directory=DIRECTORY   The directory to clean. (default './').
        -a, --ask                   Ask for confirmation before removal.
            --dry                   Only print out the actions.
        -d, --rmdir                 Remove directories.
                                    BEWARE: Everything inside the directories will
                                    be removed recursively without asking, even with
                                    '--ask'.
        -r, --recursive             Recurse into subdirectories.
        -v, --verbose               Use verbose output.
            --help                  Print this dialog.
            --version               Print dialog about version.

    Cleanfile specification:
        A 'cleanfile' is a plain text file containing the patterns to use separated
        by space, horizontal tab, newline or a combination of them. Comments are
        supported and are delimited by '#'.  Everything after '#' until a newline
        is considered a comment.

        By beginning the first line of the file with '#!' some flags can be set to
        either 0 (disabled) or 1 (enabled). The flags must be separated by a
        whitespace.

        Flag:           Effect:
        ask             Do not/do ask for confirmation (default = 0)
        rm-dir          Do not/do delete directories (dafault = 0)
        recursive       Turn off/on recurse into subdirectories (default = 0)
        verbose         Do not/do use verbose output (default = 0)

    Examples:
        cleanfile:
            #! ask=1 verbose=1
            alpha.* beta.* # Remove every file beginning with 'alpha' and 'beta'

        command:
            clean -ar -f~/file      Clean CWD, asking for confirmation, recursing
                                    into subdirectories using ~/file as the
                                    cleanfile.'''
    print(dialog)
    exit()


def print_version():
    """Print version and exit"""
    version = '''clean - BreadyX's utils (BXU). Version 1.0.0
    Written by BreadyX. Contacts (for bug reports and other):
    "GitHub repo (BXU):  https://github.com/BreadyX/bxu'''
    print(version)
    exit()


def compile_cli_patterns(cli_patterns):
    """Compile cli_patterns into a single regex expression and return it"""
    joined_cli_patterns = '(' + ')|('.join(cli_patterns) + ')'
    patterns = compile(joined_cli_patterns)
    return patterns


def validate_cleanfile(to_validate):
    """Verifify that 'to_validate' is a valid file then return it"""
    if not os.path.isfile(to_validate):
        raise ValueError(f'cleanfile {to_validate} is not a valid file')
    return to_validate


def validate_directory(to_validate):
    """Verifify that 'to_validate' is a valid directory then return it"""
    if not os.path.isdir(to_validate):
        raise ValueError(f'{to_validate} is not a valid directory')
    return to_validate


def find_cleanfile(directory):
    """
    Construct path then check the existance of the result. If it doesn't exist,
    raise ValueError.

    Return the validated path.
    """
    return validate_cleanfile(os.path.join(directory, 'cleanfile'))


def parse_cleanfile_options(cleanfile):
    """
    Read file with path 'cleanfile', search for the header and if found
    parse the options. At last return the parsed options.
    """
    flags = {'ask': False, 'rmdir': False, 'recursive': False,
             'verbose': False}
    flag_regex = compile(f'({"|".join(flags.keys())})=([0-1])')
    read_flags = []
    with open(cleanfile) as file:
        if file.read(2) == '#!':
            read_flags = file.readline().rstrip('\n').split()
        else:
            return flags
    for flag in read_flags:
        match = flag_regex.search(flag)
        if not match:
            raise ValueError(f'{flag} in cleanfile is not valid')
        flag_name, flag_value = match.groups()
        flags[flag_name] = bool(flag_value)
    return flags


def merge(into, other):
    """Merge option list 'other' into 'into' and ther return 'into'"""
    for into_key in into.keys():
        if into_key in other:
            into[into_key] = other[into_key]
    return into


def compile_cleanfile_patterns(cleanfile):
    """
    Clean file with path 'cleanfile' using awk making them similar to the cli
    ones and compile the regular expressions with compile_cli_patterns.

    Return compiled patterns.
    """
    awk_script = r'''
        BEGIN { OFS = FS = "\"" }
        {
            $0 = gensub(/#.*$/, "", "g"); # Remove comments
            $0 = gensub(/ *$/, "", "g"); # Remove trailing
            $0 = gensub(/^ */, "", "g"); # Remove trailing
            for (i=1; i<=NF; i+=2) {
                gsub(/[ \t]/, "\n", $i); # Split except in quotes
            }
            $0 = gensub(/"/, "", "g"); # Remove quotes
            if (NF>0 && NR!=1) { print; } # Remove empty lines
        }'''
    raw_patterns = check_output(['awk', awk_script, cleanfile])
    raw_patterns = raw_patterns.decode(stdout.encoding)
    return compile_cli_patterns(raw_patterns.splitlines())


def clean_files(walkinfo, pattern, options):
    """
    Delete each file in 'walkinfo[2]' if it matches with 'pattern'.
    If 'rmdir' also delete every directory in 'dirs'. The flags (ask, dry,
    verbose) modify the deletion by doing what their name implies
    """
    for fname in walkinfo[2]:
        match = pattern.search(fname)
        if (not (match and match.group(0))) or fname == 'cleanfile':
            continue
        if options['dry']:
            print(f'Deleted {fname}')
        else:
            remove_file(os.path.join(walkinfo[0], fname), options)


def clean_dirs(walkinfo, pattern, options):
    """
    Delete each dir recursively in 'walkinfo[1]' if it matches with 'pattern'.
    """
    for dirname in walkinfo[1]:
        match = pattern.search(dirname)
        if not (match and match.group(0)):
            continue
        if options['dry']:
            print(f'Deleted {dirname}')
        remove_dir(os.path.join(walkinfo[0], dirname), options)


def remove_file(path, options):
    """Remove 'path'. If ask option is set, ask for confirmation before"""
    if options['ask'] and not ask_confirmation(path, 'file'):
        return
    if options['verbose']:
        print(f'Deleted file: {path}')
    try:
        os.remove(path)
    except OSError as error:
        if error.errno == 13:  # Errno 13: permission denied
            print(f'Skipping {path}: permission denied')
            return
        raise error


def remove_dir(path, options):
    """
    Remove 'path'. If ask option is set, ask for confirmation before.

    If directory is not empty delete every file and directory inside it
    (basically rm -rf path).
    """
    if options['ask'] and not ask_confirmation(path, 'directory'):
        return
    try:
        os.rmdir(path)
    except OSError as error:
        if error.errno == 13:  # Errno13: permission denied
            print(f'Skipping {path}: permission denied')
            return
        if error.errno != 39:  # Errno 39: directory is not empty
            raise error
        recursive_options = options.copy()
        recursive_options['ask'] = False
        recursive_options['verbose'] = False
        for walkinfo in os.walk(path):
            clean_files(walkinfo, compile('.*'), recursive_options)
            clean_dirs(walkinfo, compile('.*'), recursive_options)
        try:
            os.rmdir(path)
        except OSError:
            print(f'Cannot remove {path}. Check directory permissions')
            return

    if options['verbose']:
        print(f'Deleted directory: {path}')


def ask_confirmation(path, type_to_remove):
    """
    Ask user for confirmation and return the outcome. Loop until user gives
    a valid answer
    """
    csi_up_one_delete_line = f'\033[1A\033[0G\033[2K'
    while True:
        answer = 'n'
        try:
            answer = input(f'Delete {type_to_remove} {path}? [y/n] ')
        except EOFError:
            exit()
        if answer == 'y':
            print(csi_up_one_delete_line, end='')
            return True
        if answer == 'n':
            print(csi_up_one_delete_line, end='')
            return False
        print(csi_up_one_delete_line, end='')


def format_error(string):
    """Format with coloring and stuff an error message 'string'"""
    sgr_red = "\033[31m"
    sgr_rst = "\033[0m"
    return (f'{sgr_red}Error: {string}{sgr_rst}.\n'
            'Use clean --help for more info.')


if __name__ == '__main__':
    try:
        if os.geteuid() == 0:
            print('RUNNING WITH ROOT PRIVILEGES. BE CAREFUL!')
            input('Press any key to continue...')
        main()
    except (KeyboardInterrupt, SystemExit):
        pass
    except ValueError as error:
        if os.environ.get('CLEAN_DEBUG'):
            raise error
        print(format_error(str(error)))
        exit(1)
