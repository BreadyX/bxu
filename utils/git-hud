#! /bin/sh -e

# Print formatted information about the git repository, if it exists, in the 
# current directory.

VERSION="9.2019.0"
err() {
    # Pretty print errors #
    RED=$(tput setaf 1)
    RESET=$(tput sgr0)
    printf "E: %s\n" "$RESET$RED$1$RESET" >&2
    exit 1
}
info_dialog() {
    # Print help or version dialog depending on argument. If 'help' print the help #
    # one, if 'version' print the version one.                                     #
    HELP_DIALOG="Usage: git-hud [ OPTION | LEVELS ]
Format a quick summary about the current git repository and print it to standard
output.

The script recurses up LEVELS looking for a '.git' directory (default 1). 
LEVELS has a range of 0 to 99. If passed LEVELS is outside that range, it won't
be seen as a valid argument.

If environment variable GIT_HUD_GLYPH is set to 'N' the script won't use any of 
the fontawesome glyphs.

    --help      Print this dialog
    --version   Print dialog containing info about version
    
Example: git-hud 5"
    VERSION_DIALOG="git-hud - BreadyX's utils (BXU). Version $VERSION
Written by BreadyX, contacts (for bug reports and other):
    Github profile:     https://github.com/BreadyX
    GitHub repo (BXU):  https://github.com/BreadyX/bxu"
    if [ "$1" = 'help' ]; then
        printf "%s\n\n%s\n" "$HELP_DIALOG" "$VERSION_DIALOG"
    elif [ "$1" = 'version' ]; then
        printf "%s\n" "$VERSION_DIALOG"
    fi
    exit 0
}

# Print prompt after assinging all the correct values
draw_prompt() {
    # Status-related variables
    BRANCH="-"
    STASH=""
    UNPUSH=""
    UNSTAGE=""
    UNTRACK=""
    # Check if we want fontawesome glyphs disabled
    if [ "$GIT_HUD_GLYPH" = 'N' ] || [ "$GIT_HUD_GLYPH" = '0' ]; then
        BRANCH_GLYPH="|/"
    else
        BRANCH_GLYPH="ï„¦"
    fi
    # Current branch
    BRANCHES="$(git branch)"
    [ -n "$BRANCHES" ] && BRANCH="$(echo "$BRANCHES" | grep '*' | sed 's/\* //')"
    # Stashed changes
    [ -n "$(git stash list)" ] && STASH="$"
    # Unpushed commits
    [ -n "$(git log --branches --not --remotes --oneline)" ] && UNPUSH="+"
    # Unstaged and untracked files/changes
    MODS="$(git status -u -s)"
    (echo "$MODS" | grep -q '^A\|^ M\|^  D') && UNSTAGE="*"
    (echo "$MODS" | grep -q '??') && UNTRACK="?"
    # Output
    printf "%s; [%s]" "$BRANCH_GLYPH $BRANCH" "$UNSTAGE$UNTRACK$UNPUSH$STASH"
}

# Eval arguments
N_RECURSE=0
CUR_LEVEL='./'
case $1 in
    "--help")
        info_dialog 'help' ;;
    "--version")
        info_dialog 'version' ;;
    [0-9]|[0-9][0-9])
        N_RECURSE="$1" ;;
    "")
        N_RECURSE=1 ;;
    *)
        err "Invalid argument '$1', please check help dialog for info" ;;
esac

# Loop until N_RECURSE is 0. If a '.git' directory is found, draw the prompt and
# break out of the loop, else go down one level and try again
while [ "$N_RECURSE" -gt 0 ]; do
    if [ -d "$CUR_LEVEL/.git" ]; then
        draw_prompt
        break
    else
        CUR_LEVEL="../$CUR_LEVEL"
        N_RECURSE=$((N_RECURSE - 1))
    fi
done

# Exit because we are all done and everything is good
exit 0
