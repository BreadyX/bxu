#! /bin/sh -e

# Split FILE into multiple files by dividing it into multiple files with STEP
# lines each named FILE_PREFIX plus the index. Finally put them in OUTPUT_DIRECTORY.

VERSION="8.2019.2"

err() {
    # Pretty print errors #
    RED=$(tput setaf 1)
    RESET=$(tput sgr0)
    printf "E: %s\n" "$RESET$RED$1$RESET" >&2
    exit 1
}
info_dialog() {
    # Print help or version dialog depending on argument. If 'help' print the help #
    # one, if 'version' print the version one. If neither, throw confused error.   #
    HELP_DIALOG="Usage: bsplit [OPTION]... [FILE]
Split FILE into multiple files by dividing it into multiple files with STEP
lines each named FILE_PREFIX plus the index. Finally put them in OUTPUT_DIRECTORY.

If FILE is omitted or is equal to '-', read from standard input. If no options are
specified, STEP is assumed to be 10, OUTPUT_DIRECTORY is './split' (if it
doesn't exist it will be created) and FILE_PREFIX is 'part'.

    --output-dir=OUTPUT_DIRECTORY   Output files into specified OUTPUT_DIRECTORY directory
    --step=STEP                     Separate into files with specified STEP
    --file-prefix=FILE_PREFIX       The newly created files will have the specified FILE_PREFIX
    --quiet                         Suppress output to standard output
    --help                          Print this dialog
    --version                       Print dialog containing info about version

Examples:
    split --step 5 file         Splits 'file' into files containing 5 lines each
                                and puts them into './split'
    split --step 5 --output-dir './out/' file   Splits 'file' into files containing
                                                5 lines each and puts them into './out'"
    VERSION_DIALOG="bsplit - BreadyX's utils (BXU). Version $VERSION
This program has been written by BreadyX, contacts (for bug reports and other):
    Github profile:     https://github.com/BreadyX
    GitHub repo (BXU):  https://github.com/BreadyX/bxu"
    if [ "$1" = 'help' ]; then
        printf "%s\n\n%s\n" "$HELP_DIALOG" "$VERSION_DIALOG"
    elif [ "$1" = 'version' ]; then
        printf "%s\n" "$VERSION_DIALOG"
    fi
    exit 0
}

# Arg eval values
SHIFT=1
FILE=""
OUTPUT_DIR=""
FILE_PREFIX="part"
QUIET=0
STEP=10
# Loop that evaluates all arguments passed
while [ $# -gt 0 ]; do
    case $1 in
        "--output-dir"|"--output-dir="*)
            # First check if using '--option=' and then assign OUTPUT_DIR
            # depending on result
            if (echo "$1" | grep -q '\-\-output-dir='); then
                OUTPUT_DIR="$(echo "$1" | sed 's/--output-dir=//')"
                SHIFT=1
            else
                OUTPUT_DIR="$2"
                SHIFT=2
            fi
            # Expand tilde
            (echo "$OUTPUT_DIR" | grep -q '~') && OUTPUT_DIR="$HOME${OUTPUT_DIR#"~"}"
            # Check if OUTPUT_DIR is legal
            [ -d "$OUTPUT_DIR" ] || err "$OUTPUT_DIR is not a valid directory."
            # Shift arguments
            shift "$SHIFT" 2>/dev/null || err "Missing argument for --output-dir" ;;
        "--step"|"--step="*)
            # First check if using '--option=' and then assign STEP
            # depending on result
            if (echo "$1" | grep -q '\-\-step='); then
                STEP="$(echo "$1" | sed 's/--step=//')"
                SHIFT=1
            else
                STEP="$2"
                SHIFT=2
            fi
            # Check if STEP is legal
            (echo "$STEP" | grep -Eq '^[0-9]+$') || err "$STEP is not a valid number."
            # Shift arguments
            shift "$SHIFT" 2>/dev/null || err "Missing argument for --step" ;;
        "--file-prefix"|"--file-prefix="*)
            # First check if using '--option=' and then assign FILE_PREFIX
            # depending on result
            if (echo "$1" | grep -q '\-\-file-prefix='); then
                FILE_PREFIX="$(echo "$1" | sed 's/--file-prefix=//')"
                SHIFT=1
            else
                FILE_PREFIX="$2"
                SHIFT=2
            fi
            # Check if FILE_PREFIX is legal
            (echo "$FILE_PREFIX" | grep -q '\/\|\*') && err "File prefix '$FILE_PREFIX' is not valid."
            # Shift arguments
            shift "$SHIFT" 2>/dev/null || err "Missing argument for --file-prefix" ;;
        "--quiet") # Set QUIET flag
            QUIET=1
            shift ;;
        "--help") # Print help dialog and exit
            info_dialog 'help' ;;
        "--version") # Print version dialog and exit
            info_dialog 'version' ;;
        "--"*) # Check for invalid option, the throw an error and exit
            err "Invalid option $1, please check help dialog for info." ;;
        *) # Check if FILE has been already specified
            [ -z "$FILE" ] || err "Input file has been already specified."
            FILE="$1"
            # Check if FILE is legal
            if ! [ -f "$FILE" ] && ! [ "$FILE" = '-' ]; then
                err "Specified file $FILE is not a valid file"
            fi
            shift ;;
    esac
done
# Content-relative variables
CONTENT=""
TOTAL_LINES=0
# Check if FILE has been set, if not read from STDIN. Based on that, assign
# TOTAL_LINES
if [ -z "$FILE" ] || [ "$FILE" = '-' ]; then
    CONTENT="$(tee)"
    TOTAL_LINES="$(echo "$CONTENT" | wc -l)"
else
    TOTAL_LINES="$(wc -l "$FILE" | cut -f1 -d ' ')"
fi
# Assign the default OUTPUT_DIR if OUTPUT_DIR is not set
if [ -z "$OUTPUT_DIR" ]; then
    OUTPUT_DIR="$(dirname "$FILE")/split"
    # Create the default OUTPUT_DIR if it doesn't exit. If it cannot be created,
    # thow an error
    [ -d "$OUTPUT_DIR" ] || mkdir "$OUTPUT_DIR" > /dev/null 2>&1 || \
        err "Cannot create output directory './split'."
fi

# Output-relative variables
CURRENT_READ=""
LOWER=0
UPPER=0
ITER=0
# Start spliting loop.
# It runs until the UPPER margin doesn't reach TOTAL_LINES
while [ "$UPPER" -le "$TOTAL_LINES" ]; do
    # Assign margins. LOWER is one above the previous UPPER and UPPER is
    # STEP + 1 above the LOWER
    LOWER=$((UPPER+1))
    UPPER=$((LOWER+STEP-1))
    # Read from file or from STDIN based on the value of FILE
    if [ -z "$FILE" ] || [ "$FILE" = '-' ]; then
        CURRENT_READ="$(echo "$CONTENT" | sed -n "${LOWER},${UPPER}p")"
    else
        CURRENT_READ="$(sed -n "${LOWER},${UPPER}p" "$FILE")"
    fi
    # Output what we read to the correct output file. The name is created by
    # concatenating the FILE_PREFIX and the ITER (nth iteration)
    # If not QUIET, print out the name of that file.
    OUTPUT_FILE="$OUTPUT_DIR/$FILE_PREFIX$ITER"
    echo "$CURRENT_READ" > "$OUTPUT_FILE"
    [ "$QUIET" -eq 0 ] && printf "%s\n" "$OUTPUT_FILE"
    # Increment ITER value
    ITER=$((ITER+1))
done

# Exit because we are done and everything is good
exit 0
