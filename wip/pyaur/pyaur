#! /usr/bin/env python3
"""AUR helper"""
# import urllib.request
# import json
# import subprocess
import sys
import os
import getopt
import pathlib
import re
import textwrap

# Program information
NAME = 'aur'
VERSION = '0.0.2'
SYNTAX = f'Usage: {NAME} [option]... [packages]...'
OVERVIEW = ('Simple AUR helper that can install, search and get info on '
            'packages from the AUR. Every download is kept into the ".aur" '
            "folder inside the user's home directory.")
OPTIONS = {'install':     ('-I', '--install', 'I',
                           "Install a package from the AUR"),
           'build':       ('-B', '--build', 'B',
                           "Download and build a package from the AUR"),
           'get':         ('-C', '--clone', 'C',
                           "Download the port of a package from the AUR"),
           'upgrade':     ('-U', '--upgrade', 'U',
                           "Upgrade all installed AUR packages"),
           'info':        ('-Q', '--info', 'Q',
                           "Get information about a package from the AUR"),
           'search':      ('-S', '--search', 'S',
                           "Search the AUR for a package"),
           'to-pacman':   (' ', '--to-pacman=', '',
                           "Pass <options> to pacman -U " +
                           "(to be used only when installing)"),
           'to-makepkg':  (' ', '--to-makepkg=', '',
                           "Pass <options> to makepkg " +
                           "(to be used only when building or installing)"),
           'quiet':       ('-q', '--quiet', '', "Print less output"),
           'verbose':     ('-v', '--verbose', '', "Print more output"),
           'help':        ('-h', '--help', 'H', "Print this dialog"),
           'version':     ('-V', '--version', 'V',
                           "Print a dialog containing info about version")
           }
ADDTIONAL_INFO = ('')

# Access OPTIONS dict without magic numers
SHORT_OPT = 0
LONG_OPT = 1
DESC_OPT = 3
ACTION = 2

# Default config
CONFIG_LOCATIONS = (pathlib.Path(f'/etc/{NAME}/config'),
                    pathlib.Path(os.path.expanduser(f'~/.config/{NAME}/config')),
                    pathlib.Path('./config')  # Debug
                    )
CONFIG_CLEAN_REGEX = re.compile('(#.*$)|(\s*$)|(^\s*)')
CONFIG_KEY_REGEX = re.compile('(\S*)\s*(\S*)')
DEFAULT_CONFIG = {'db-path': '',
                  'cache-path': ''}


def main():
    """Main function"""
    options, arguments = eval_argv(sys.argv[1:])
    action, flags = eval_options(options)
    # Read configs file
    config = parse_configs()
    print(config)
    # Evaulate action


def make_dialog(typ):
    """Construct help and version dialogs"""
    dialog = ''
    if typ == OPTIONS['help'][ACTION]:
        dialog += SYNTAX + '\n' * 2  # add syntax
        dialog += textwrap.fill(OVERVIEW, 80) + '\n' * 2  # add overview
        for short, long, _, description in OPTIONS.values():  # add options
            dialog += f'\t{short:2}, {long}\t{description}\n'
        dialog += textwrap.fill(ADDITIONAL_INFO, 80)  # add additional info
    elif typ == OPTIONS['version'][ACTION]:
        dialog = (f'{NAME} - BreadyX\'s utils. Version {VERSION}.'
                  'Written bt BreadyX.\n\tContacts:\n'
                  'https://github.com/BreadyX/bxu')
    else:
        raise RuntimeError(f'Invalid type {typ}')
    return dialog


def eval_argv(argv):
    """Parse argv and return options and arguments"""
    short = ''.join([s[SHORT_OPT][1:] for s in OPTIONS.values()])
    long = [l[LONG_OPT][2:] for l in OPTIONS.values()]
    try:
        return getopt.getopt(argv, short, long)
    except getopt.GetoptError as err:
        raise RuntimeError(str(err))


def eval_options(options):
    """Evaluate passed options"""
    action = OPTIONS['help'][ACTION]  # Default action
    flags = {'quiet': False, 'verbose': False, 'to-pacman': '',
             'to-makepkg': ''}
    for option, value in options:
        for short, long, opt_action, _ in OPTIONS.values():
            if option in (short, long, long[0:-1]):  # option matches current
                if opt_action != '':
                    action = opt_action
                else:
                    if long[-1] == '=':
                        flags[long[2:-1]] = value
                    else:
                        flags[long[2:]] = value
    return action, flags


def parse_configs():
    """
    Parse configuration files if found in CONFIG_LOCATIONS. The order in
    which the files are parse matters
    """
    config = DEFAULT_CONFIG.copy()
    for config_file in CONFIG_LOCATIONS:
        if os.path.isfile(config_file):
            keys = None
            with open(config_file) as file:
                keys = [parse_config_line(line) for line in file if line]
            for key in keys:
                if key is not None:
                    if key[0] in config:
                        config[key[0]] = key[1]
                    else:
                        raise RuntimeError(f'Key {key} in config file '
                                           f'{config_file} is not valid')
    return config


def parse_config_line(line):
    # strip comments and trailing whitespaces
    clean_line = CONFIG_CLEAN_REGEX.sub('', line)
    if clean_line == '':  # empty line
        return None
    # Capturing groups in CONFIG_KEY_REGEX are 2 so can expand
    # safely
    return CONFIG_KEY_REGEX.search(clean_line).groups()

if __name__ == '__main__':
    try:
        main()
    except RuntimeError as err:
        print(f'\033[31mError: {str(err)}.\033[0m\n'
              f'Use {NAME} {OPTIONS["help"][LONG_OPT]} for info on usage.')
